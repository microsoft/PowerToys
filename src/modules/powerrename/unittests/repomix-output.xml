This file is a merged representation of a subset of the codebase, containing specifically included files and files not matching ignore patterns, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: **/*.cpp, **/*.h
- Files matching these patterns are excluded: **/pch.*, **/Generated Files/*
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
CommonRegExTests.h
CppUnitTestInclude.h
MockPowerRenameItem.cpp
MockPowerRenameItem.h
MockPowerRenameManagerEvents.cpp
MockPowerRenameManagerEvents.h
MockPowerRenameRegExEvents.cpp
MockPowerRenameRegExEvents.h
pch.cpp
pch.h
PowerRenameManagerTests.cpp
PowerRenameRegExBoostTests.cpp
PowerRenameRegExTests.cpp
resource.h
targetver.h
TestFileHelper.cpp
TestFileHelper.h
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="CommonRegExTests.h">
//#undef TESTS_PARTIAL // Uncomment temporarily to make intellisense work in this file.
#ifndef TESTS_PARTIAL
#include "CppUnitTestInclude.h"
#include "powerrename/lib/Settings.h"
#include <PowerRenameInterfaces.h>
#include <PowerRenameRegEx.h>

using namespace Microsoft::VisualStudio::CppUnitTestFramework;
namespace PowerRenameRegExTests
{
TEST_CLASS (SimpleTests)
{
public:
#endif

struct SearchReplaceExpected
{
    PCWSTR search;
    PCWSTR replace;
    PCWSTR test;
    PCWSTR expected;
};

TEST_METHOD (GeneralReplaceTest)
{
    CComPtr<IPowerRenameRegEx> renameRegEx;
    Assert::IsTrue(CPowerRenameRegEx::s_CreateInstance(&renameRegEx) == S_OK);
    PWSTR result = nullptr;
    Assert::IsTrue(renameRegEx->PutSearchTerm(L"foo") == S_OK);
    Assert::IsTrue(renameRegEx->PutReplaceTerm(L"big") == S_OK);
    unsigned long index = {};
    Assert::IsTrue(renameRegEx->Replace(L"foobar", &result, index) == S_OK);
    Assert::AreEqual(L"bigbar", result);
    CoTaskMemFree(result);
}

TEST_METHOD (ReplaceNoMatch)
{
    CComPtr<IPowerRenameRegEx> renameRegEx;
    Assert::IsTrue(CPowerRenameRegEx::s_CreateInstance(&renameRegEx) == S_OK);
    PWSTR result = nullptr;
    Assert::IsTrue(renameRegEx->PutSearchTerm(L"notfound") == S_OK);
    Assert::IsTrue(renameRegEx->PutReplaceTerm(L"big") == S_OK);
    unsigned long index = {};
    Assert::IsTrue(renameRegEx->Replace(L"foobar", &result, index) == S_OK);
    Assert::AreEqual(L"foobar", result);
    CoTaskMemFree(result);
}

TEST_METHOD (ReplaceNoSearchOrReplaceTerm)
{
    CComPtr<IPowerRenameRegEx> renameRegEx;
    Assert::IsTrue(CPowerRenameRegEx::s_CreateInstance(&renameRegEx) == S_OK);
    PWSTR result = nullptr;
    unsigned long index = {};
    Assert::IsTrue(renameRegEx->Replace(L"foobar", &result, index) == S_OK);
    Assert::IsTrue(result == nullptr);
    CoTaskMemFree(result);
}

TEST_METHOD (ReplaceNoReplaceTerm)
{
    CComPtr<IPowerRenameRegEx> renameRegEx;
    Assert::IsTrue(CPowerRenameRegEx::s_CreateInstance(&renameRegEx) == S_OK);
    PWSTR result = nullptr;
    Assert::IsTrue(renameRegEx->PutSearchTerm(L"foo") == S_OK);
    unsigned long index = {};
    Assert::IsTrue(renameRegEx->Replace(L"foobar", &result, index) == S_OK);
    Assert::AreEqual(L"bar", result);
    CoTaskMemFree(result);
}

TEST_METHOD (ReplaceEmptyStringReplaceTerm)
{
    CComPtr<IPowerRenameRegEx> renameRegEx;
    Assert::IsTrue(CPowerRenameRegEx::s_CreateInstance(&renameRegEx) == S_OK);
    PWSTR result = nullptr;
    Assert::IsTrue(renameRegEx->PutSearchTerm(L"foo") == S_OK);
    Assert::IsTrue(renameRegEx->PutReplaceTerm(L"") == S_OK);
    unsigned long index = {};
    Assert::IsTrue(renameRegEx->Replace(L"foobar", &result, index) == S_OK);
    Assert::AreEqual(L"bar", result);
    CoTaskMemFree(result);
}

TEST_METHOD (VerifyDefaultFlags)
{
    CComPtr<IPowerRenameRegEx> renameRegEx;
    Assert::IsTrue(CPowerRenameRegEx::s_CreateInstance(&renameRegEx) == S_OK);
    DWORD flags = 0;
    Assert::IsTrue(renameRegEx->GetFlags(&flags) == S_OK);
    Assert::IsTrue(flags == 0);
}

TEST_METHOD (VerifyCaseSensitiveSearch)
{
    CComPtr<IPowerRenameRegEx> renameRegEx;
    Assert::IsTrue(CPowerRenameRegEx::s_CreateInstance(&renameRegEx) == S_OK);
    DWORD flags = CaseSensitive;
    Assert::IsTrue(renameRegEx->PutFlags(flags) == S_OK);

    SearchReplaceExpected sreTable[] = {
        { L"Foo", L"Foo", L"FooBar", L"FooBar" },
        { L"Foo", L"boo", L"FooBar", L"booBar" },
        { L"Foo", L"boo", L"foobar", L"foobar" },
        { L"123", L"654", L"123456", L"654456" },
    };

    for (int i = 0; i < ARRAYSIZE(sreTable); i++)
    {
        PWSTR result = nullptr;
        Assert::IsTrue(renameRegEx->PutSearchTerm(sreTable[i].search) == S_OK);
        Assert::IsTrue(renameRegEx->PutReplaceTerm(sreTable[i].replace) == S_OK);
        unsigned long index = {};
        Assert::IsTrue(renameRegEx->Replace(sreTable[i].test, &result, index) == S_OK);
        Assert::IsTrue(wcscmp(result, sreTable[i].expected) == 0);
        CoTaskMemFree(result);
    }
}

TEST_METHOD (VerifyReplaceFirstOnly)
{
    CComPtr<IPowerRenameRegEx> renameRegEx;
    Assert::IsTrue(CPowerRenameRegEx::s_CreateInstance(&renameRegEx) == S_OK);
    DWORD flags = 0;
    Assert::IsTrue(renameRegEx->PutFlags(flags) == S_OK);

    SearchReplaceExpected sreTable[] = {
        { L"B", L"BB", L"ABA", L"ABBA" },
        { L"B", L"A", L"ABBBA", L"AABBA" },
        { L"B", L"BBB", L"ABABAB", L"ABBBABAB" },
    };

    for (int i = 0; i < ARRAYSIZE(sreTable); i++)
    {
        PWSTR result = nullptr;
        Assert::IsTrue(renameRegEx->PutSearchTerm(sreTable[i].search) == S_OK);
        Assert::IsTrue(renameRegEx->PutReplaceTerm(sreTable[i].replace) == S_OK);
        unsigned long index = {};
        Assert::IsTrue(renameRegEx->Replace(sreTable[i].test, &result, index) == S_OK);
        Assert::IsTrue(wcscmp(result, sreTable[i].expected) == 0);
        CoTaskMemFree(result);
    }
}

TEST_METHOD (VerifyReplaceAll)
{
    CComPtr<IPowerRenameRegEx> renameRegEx;
    Assert::IsTrue(CPowerRenameRegEx::s_CreateInstance(&renameRegEx) == S_OK);
    DWORD flags = MatchAllOccurrences;
    Assert::IsTrue(renameRegEx->PutFlags(flags) == S_OK);

    SearchReplaceExpected sreTable[] = {
        { L"B", L"BB", L"ABA", L"ABBA" },
        { L"B", L"A", L"ABBBA", L"AAAAA" },
        { L"B", L"BBB", L"ABABAB", L"ABBBABBBABBB" },
    };

    for (int i = 0; i < ARRAYSIZE(sreTable); i++)
    {
        PWSTR result = nullptr;
        Assert::IsTrue(renameRegEx->PutSearchTerm(sreTable[i].search) == S_OK);
        Assert::IsTrue(renameRegEx->PutReplaceTerm(sreTable[i].replace) == S_OK);
        unsigned long index = {};
        Assert::IsTrue(renameRegEx->Replace(sreTable[i].test, &result, index) == S_OK);
        Assert::IsTrue(wcscmp(result, sreTable[i].expected) == 0);
        CoTaskMemFree(result);
    }
}

TEST_METHOD (VerifyReplaceAllCaseInsensitive)
{
    CComPtr<IPowerRenameRegEx> renameRegEx;
    Assert::IsTrue(CPowerRenameRegEx::s_CreateInstance(&renameRegEx) == S_OK);
    DWORD flags = MatchAllOccurrences | CaseSensitive;
    Assert::IsTrue(renameRegEx->PutFlags(flags) == S_OK);

    SearchReplaceExpected sreTable[] = {
        { L"B", L"BB", L"ABA", L"ABBA" },
        { L"B", L"A", L"ABBBA", L"AAAAA" },
        { L"B", L"BBB", L"ABABAB", L"ABBBABBBABBB" },
        { L"b", L"BBB", L"AbABAb", L"ABBBABABBB" },
    };

    for (int i = 0; i < ARRAYSIZE(sreTable); i++)
    {
        PWSTR result = nullptr;
        Assert::IsTrue(renameRegEx->PutSearchTerm(sreTable[i].search) == S_OK);
        Assert::IsTrue(renameRegEx->PutReplaceTerm(sreTable[i].replace) == S_OK);
        unsigned long index = {};
        Assert::IsTrue(renameRegEx->Replace(sreTable[i].test, &result, index) == S_OK);
        Assert::IsTrue(wcscmp(result, sreTable[i].expected) == 0);
        CoTaskMemFree(result);
    }
}

TEST_METHOD (VerifyReplaceFirstOnlyUseRegEx)
{
    CComPtr<IPowerRenameRegEx> renameRegEx;
    Assert::IsTrue(CPowerRenameRegEx::s_CreateInstance(&renameRegEx) == S_OK);
    DWORD flags = UseRegularExpressions;
    Assert::IsTrue(renameRegEx->PutFlags(flags) == S_OK);

    SearchReplaceExpected sreTable[] = {
        { L"B", L"BB", L"ABA", L"ABBA" },
        { L"B", L"A", L"ABBBA", L"AABBA" },
        { L"B", L"BBB", L"ABABAB", L"ABBBABAB" },
    };

    for (int i = 0; i < ARRAYSIZE(sreTable); i++)
    {
        PWSTR result = nullptr;
        Assert::IsTrue(renameRegEx->PutSearchTerm(sreTable[i].search) == S_OK);
        Assert::IsTrue(renameRegEx->PutReplaceTerm(sreTable[i].replace) == S_OK);
        unsigned long index = {};
        Assert::IsTrue(renameRegEx->Replace(sreTable[i].test, &result, index) == S_OK);
        Assert::IsTrue(wcscmp(result, sreTable[i].expected) == 0);
        CoTaskMemFree(result);
    }
}

TEST_METHOD (VerifyReplaceAllUseRegEx)
{
    CComPtr<IPowerRenameRegEx> renameRegEx;
    Assert::IsTrue(CPowerRenameRegEx::s_CreateInstance(&renameRegEx) == S_OK);
    DWORD flags = MatchAllOccurrences | UseRegularExpressions;
    Assert::IsTrue(renameRegEx->PutFlags(flags) == S_OK);

    SearchReplaceExpected sreTable[] = {
        { L"B", L"BB", L"ABA", L"ABBA" },
        { L"B", L"A", L"ABBBA", L"AAAAA" },
        { L"B", L"BBB", L"ABABAB", L"ABBBABBBABBB" },
    };

    for (int i = 0; i < ARRAYSIZE(sreTable); i++)
    {
        PWSTR result = nullptr;
        Assert::IsTrue(renameRegEx->PutSearchTerm(sreTable[i].search) == S_OK);
        Assert::IsTrue(renameRegEx->PutReplaceTerm(sreTable[i].replace) == S_OK);
        unsigned long index = {};
        Assert::IsTrue(renameRegEx->Replace(sreTable[i].test, &result, index) == S_OK);
        Assert::IsTrue(wcscmp(result, sreTable[i].expected) == 0);
        CoTaskMemFree(result);
    }
}

TEST_METHOD (VerifyReplaceAllUseRegExCaseSensitive)
{
    CComPtr<IPowerRenameRegEx> renameRegEx;
    Assert::IsTrue(CPowerRenameRegEx::s_CreateInstance(&renameRegEx) == S_OK);
    DWORD flags = MatchAllOccurrences | UseRegularExpressions | CaseSensitive;
    Assert::IsTrue(renameRegEx->PutFlags(flags) == S_OK);

    SearchReplaceExpected sreTable[] = {
        { L"B", L"BB", L"ABA", L"ABBA" },
        { L"B", L"A", L"ABBBA", L"AAAAA" },
        { L"b", L"BBB", L"AbABAb", L"ABBBABABBB" },
    };

    for (int i = 0; i < ARRAYSIZE(sreTable); i++)
    {
        PWSTR result = nullptr;
        Assert::IsTrue(renameRegEx->PutSearchTerm(sreTable[i].search) == S_OK);
        Assert::IsTrue(renameRegEx->PutReplaceTerm(sreTable[i].replace) == S_OK);
        unsigned long index = {};
        Assert::IsTrue(renameRegEx->Replace(sreTable[i].test, &result, index) == S_OK);
        Assert::IsTrue(wcscmp(result, sreTable[i].expected) == 0);
        CoTaskMemFree(result);
    }
}

void VerifyReplaceFirstWildcard(SearchReplaceExpected sreTable[], int tableSize, DWORD flags)
{
    CComPtr<IPowerRenameRegEx> renameRegEx;
    Assert::IsTrue(CPowerRenameRegEx::s_CreateInstance(&renameRegEx) == S_OK);
    Assert::IsTrue(renameRegEx->PutFlags(flags) == S_OK);

    for (int i = 0; i < tableSize; i++)
    {
        PWSTR result = nullptr;
        Assert::IsTrue(renameRegEx->PutSearchTerm(sreTable[i].search) == S_OK);
        Assert::IsTrue(renameRegEx->PutReplaceTerm(sreTable[i].replace) == S_OK);
        unsigned long index = {};
        Assert::IsTrue(renameRegEx->Replace(sreTable[i].test, &result, index) == S_OK);
        Assert::AreEqual(sreTable[i].expected, result);
        CoTaskMemFree(result);
    }
}

TEST_METHOD (VerifyReplaceFirstWildCardUseRegex)
{
    SearchReplaceExpected sreTable[] = {
        //search, replace, test, result
        { L".*", L"Foo", L"AAAAAA", L"Foo" },
    };
    VerifyReplaceFirstWildcard(sreTable, ARRAYSIZE(sreTable), UseRegularExpressions);
}

TEST_METHOD (VerifyReplaceFirstWildCardMatchAllOccurrences)
{
    SearchReplaceExpected sreTable[] = {
        //search, replace, test, result
        { L".*", L"Foo", L"AAAAAA", L"AAAAAA" },
        { L".*", L"Foo", L".*", L"Foo" },
        { L".*", L"Foo", L".*Bar.*", L"FooBarFoo" },
    };
    VerifyReplaceFirstWildcard(sreTable, ARRAYSIZE(sreTable), MatchAllOccurrences);
}

TEST_METHOD (VerifyReplaceFirstWildNoFlags)
{
    SearchReplaceExpected sreTable[] = {
        //search, replace, test, result
        { L".*", L"Foo", L"AAAAAA", L"AAAAAA" },
        { L".*", L"Foo", L".*", L"Foo" },
    };
    VerifyReplaceFirstWildcard(sreTable, ARRAYSIZE(sreTable), 0);
}

TEST_METHOD (VerifyEventsFire)
{
    CComPtr<IPowerRenameRegEx> renameRegEx;
    Assert::IsTrue(CPowerRenameRegEx::s_CreateInstance(&renameRegEx) == S_OK);
    CMockPowerRenameRegExEvents* mockEvents = new CMockPowerRenameRegExEvents();
    CComPtr<IPowerRenameRegExEvents> regExEvents;
    Assert::IsTrue(mockEvents->QueryInterface(IID_PPV_ARGS(&regExEvents)) == S_OK);
    DWORD cookie = 0;
    Assert::IsTrue(renameRegEx->Advise(regExEvents, &cookie) == S_OK);
    DWORD flags = MatchAllOccurrences | UseRegularExpressions | CaseSensitive;
    Assert::IsTrue(renameRegEx->PutFlags(flags) == S_OK);
    Assert::IsTrue(renameRegEx->PutSearchTerm(L"FOO") == S_OK);
    Assert::IsTrue(renameRegEx->PutReplaceTerm(L"BAR") == S_OK);
    Assert::IsTrue(renameRegEx->PutFileTime(SYSTEMTIME{ 0 }) == S_OK);
    Assert::IsTrue(renameRegEx->ResetFileTime() == S_OK);
    Assert::IsTrue(lstrcmpi(L"FOO", mockEvents->m_searchTerm) == 0);
    Assert::IsTrue(lstrcmpi(L"BAR", mockEvents->m_replaceTerm) == 0);
    Assert::IsTrue(flags == mockEvents->m_flags);
    Assert::IsTrue(renameRegEx->UnAdvise(cookie) == S_OK);
    mockEvents->Release();
}

TEST_METHOD (VerifySimpleCounterNoRegex)
{
    CComPtr<IPowerRenameRegEx> renameRegEx;
    Assert::IsTrue(CPowerRenameRegEx::s_CreateInstance(&renameRegEx) == S_OK);
    DWORD flags = EnumerateItems;
    Assert::IsTrue(renameRegEx->PutFlags(flags) == S_OK);

    PWSTR result = nullptr;
    Assert::IsTrue(renameRegEx->PutSearchTerm(L"bar") == S_OK);
    Assert::IsTrue(renameRegEx->PutReplaceTerm(L"$1bar_${}") == S_OK);
    unsigned long index = {};
    Assert::IsTrue(renameRegEx->Replace(L"foobar", &result, index) == S_OK);
    Assert::AreEqual(L"foo$1bar_0", result);
    CoTaskMemFree(result);
}

TEST_METHOD (VerifySimpleCounterNoEnum)
{
    CComPtr<IPowerRenameRegEx> renameRegEx;
    Assert::IsTrue(CPowerRenameRegEx::s_CreateInstance(&renameRegEx) == S_OK);
    DWORD flags = UseRegularExpressions;
    Assert::IsTrue(renameRegEx->PutFlags(flags) == S_OK);

    PWSTR result = nullptr;
    Assert::IsTrue(renameRegEx->PutSearchTerm(L"bar") == S_OK);
    Assert::IsTrue(renameRegEx->PutReplaceTerm(L"$1bar_${}") == S_OK);
    unsigned long index = {};
    Assert::IsTrue(renameRegEx->Replace(L"foobar", &result, index) == S_OK);
    Assert::AreEqual(L"foobar_${}", result);
    CoTaskMemFree(result);
}

TEST_METHOD (VerifySimpleCounter)
{
    CComPtr<IPowerRenameRegEx> renameRegEx;
    Assert::IsTrue(CPowerRenameRegEx::s_CreateInstance(&renameRegEx) == S_OK);
    DWORD flags = EnumerateItems | UseRegularExpressions;
    Assert::IsTrue(renameRegEx->PutFlags(flags) == S_OK);

    PWSTR result = nullptr;
    Assert::IsTrue(renameRegEx->PutSearchTerm(L"bar") == S_OK);
    Assert::IsTrue(renameRegEx->PutReplaceTerm(L"bar_${}") == S_OK);
    unsigned long index = {};
    Assert::IsTrue(renameRegEx->Replace(L"foobar", &result, index) == S_OK);
    Assert::AreEqual(L"foobar_0", result);
    CoTaskMemFree(result);
}

TEST_METHOD (VerifyMultipleCounters)
{
    CComPtr<IPowerRenameRegEx> renameRegEx;
    Assert::IsTrue(CPowerRenameRegEx::s_CreateInstance(&renameRegEx) == S_OK);
    DWORD flags = EnumerateItems | UseRegularExpressions;
    Assert::IsTrue(renameRegEx->PutFlags(flags) == S_OK);
    Assert::IsTrue(renameRegEx->PutSearchTerm(L"bar") == S_OK);
    Assert::IsTrue(renameRegEx->PutReplaceTerm(L"_${}_bar_${}") == S_OK);
    unsigned long index = {};
    PWSTR result = nullptr;
    Assert::IsTrue(renameRegEx->Replace(L"foobar", &result, index) == S_OK);
    Assert::AreEqual(L"foo_0_bar_0", result);
    CoTaskMemFree(result);
}

TEST_METHOD (VerifyCounterIncrementCustomization)
{
    CComPtr<IPowerRenameRegEx> renameRegEx;
    Assert::IsTrue(CPowerRenameRegEx::s_CreateInstance(&renameRegEx) == S_OK);
    DWORD flags = EnumerateItems | UseRegularExpressions;
    Assert::IsTrue(renameRegEx->PutFlags(flags) == S_OK);
    Assert::IsTrue(renameRegEx->PutSearchTerm(L"bar") == S_OK);
    Assert::IsTrue(renameRegEx->PutReplaceTerm(L"bar_${increment=10}") == S_OK);
    unsigned long index = 1;
    PWSTR result = nullptr;
    Assert::IsTrue(renameRegEx->Replace(L"foobar", &result, index) == S_OK);
    Assert::AreEqual(L"foobar_10", result);
    Assert::AreEqual<unsigned long>(index, 2);
    Assert::IsTrue(renameRegEx->Replace(L"foobar", &result, index) == S_OK);
    Assert::AreEqual(L"foobar_20", result);
    Assert::AreEqual<unsigned long>(index, 3);
    CoTaskMemFree(result);
}

TEST_METHOD (VerifyCounterStartCustomization)
{
    CComPtr<IPowerRenameRegEx> renameRegEx;
    Assert::IsTrue(CPowerRenameRegEx::s_CreateInstance(&renameRegEx) == S_OK);
    DWORD flags = EnumerateItems | UseRegularExpressions;
    Assert::IsTrue(renameRegEx->PutFlags(flags) == S_OK);
    Assert::IsTrue(renameRegEx->PutSearchTerm(L"bar") == S_OK);
    Assert::IsTrue(renameRegEx->PutReplaceTerm(L"bar_${start=1000}") == S_OK);
    unsigned long index = 5;
    PWSTR result = nullptr;
    Assert::IsTrue(renameRegEx->Replace(L"foobar", &result, index) == S_OK);
    Assert::AreEqual(L"foobar_1005", result);
    CoTaskMemFree(result);
}

TEST_METHOD (VerifyCounterPaddingCustomization)
{
    CComPtr<IPowerRenameRegEx> renameRegEx;
    Assert::IsTrue(CPowerRenameRegEx::s_CreateInstance(&renameRegEx) == S_OK);
    DWORD flags = EnumerateItems | UseRegularExpressions;
    Assert::IsTrue(renameRegEx->PutFlags(flags) == S_OK);
    Assert::IsTrue(renameRegEx->PutSearchTerm(L"bar") == S_OK);
    Assert::IsTrue(renameRegEx->PutReplaceTerm(L"bar_${padding=5}") == S_OK);
    unsigned long index = 204;
    PWSTR result = nullptr;
    Assert::IsTrue(renameRegEx->Replace(L"foobar", &result, index) == S_OK);
    Assert::AreEqual(L"foobar_00204", result);
    CoTaskMemFree(result);
}

TEST_METHOD (VerifyCounterAllCustomizations)
{
    CComPtr<IPowerRenameRegEx> renameRegEx;
    Assert::IsTrue(CPowerRenameRegEx::s_CreateInstance(&renameRegEx) == S_OK);
    DWORD flags = EnumerateItems | UseRegularExpressions;
    Assert::IsTrue(renameRegEx->PutFlags(flags) == S_OK);
    Assert::IsTrue(renameRegEx->PutSearchTerm(L"bar") == S_OK);
    Assert::IsTrue(renameRegEx->PutReplaceTerm(L"bar_${increment=7,start=993,padding=5}") == S_OK);
    unsigned long index = 12;
    PWSTR result = nullptr;
    Assert::IsTrue(renameRegEx->Replace(L"foobar", &result, index) == S_OK);
    Assert::AreEqual(L"foobar_01077", result);
    CoTaskMemFree(result);
}

TEST_METHOD (VerifyRandomizerDefaultFlags)
{
    CComPtr<IPowerRenameRegEx> renameRegEx;
    Assert::IsTrue(CPowerRenameRegEx::s_CreateInstance(&renameRegEx) == S_OK);
    DWORD flags = 0;
    Assert::IsTrue(renameRegEx->PutFlags(flags) == S_OK);
    PWSTR result = nullptr;
    Assert::IsTrue(renameRegEx->PutSearchTerm(L"bar") == S_OK);
    Assert::IsTrue(renameRegEx->PutReplaceTerm(L"$1bar_${rstringalnum=9}") == S_OK);
    unsigned long index = {};
    Assert::IsTrue(renameRegEx->Replace(L"foobar", &result, index) == S_OK);
    Assert::AreEqual(L"foo$1bar_${rstringalnum=9}", result);
    CoTaskMemFree(result);
}

TEST_METHOD (VerifyRandomizerNoRegex)
{
    CComPtr<IPowerRenameRegEx> renameRegEx;
    Assert::IsTrue(CPowerRenameRegEx::s_CreateInstance(&renameRegEx) == S_OK);
    DWORD flags = RandomizeItems;
    Assert::IsTrue(renameRegEx->PutFlags(flags) == S_OK);
    PWSTR result = nullptr;
    Assert::IsTrue(renameRegEx->PutSearchTerm(L"bar") == S_OK);
    Assert::IsTrue(renameRegEx->PutReplaceTerm(L"$1bar_${}") == S_OK);
    unsigned long index = {};
    Assert::IsTrue(renameRegEx->Replace(L"foobar", &result, index) == S_OK);
    Assert::AreEqual(L"foo$1bar_${}", result);
    CoTaskMemFree(result);
}

TEST_METHOD (VerifyRandomizerNoRandomizerRegEx)
{
    CComPtr<IPowerRenameRegEx> renameRegEx;
    Assert::IsTrue(CPowerRenameRegEx::s_CreateInstance(&renameRegEx) == S_OK);
    DWORD flags = UseRegularExpressions;
    Assert::IsTrue(renameRegEx->PutFlags(flags) == S_OK);
    PWSTR result = nullptr;
    Assert::IsTrue(renameRegEx->PutSearchTerm(L"bar") == S_OK);
    Assert::IsTrue(renameRegEx->PutReplaceTerm(L"$1bar_${rstringalnum=9}") == S_OK);
    unsigned long index = {};
    Assert::IsTrue(renameRegEx->Replace(L"foobar", &result, index) == S_OK);
    Assert::AreEqual(L"foobar_${rstringalnum=9}", result);
    CoTaskMemFree(result);
}

TEST_METHOD (VerifyRandomizerRegEx)
{
    CComPtr<IPowerRenameRegEx> renameRegEx;
    Assert::IsTrue(CPowerRenameRegEx::s_CreateInstance(&renameRegEx) == S_OK);
    DWORD flags = RandomizeItems | UseRegularExpressions;
    Assert::IsTrue(renameRegEx->PutFlags(flags) == S_OK);
    PWSTR result = nullptr;
    Assert::IsTrue(renameRegEx->PutSearchTerm(L"bar") == S_OK);
    Assert::IsTrue(renameRegEx->PutReplaceTerm(L"$1bar_${rstringalnum=9}") == S_OK);
    unsigned long index = {};
    Assert::IsTrue(renameRegEx->Replace(L"foobar", &result, index) == S_OK);
    std::wstring resultStr(result);
    std::wregex pattern(L"foobar_\\w{9}");
    Assert::IsTrue(std::regex_match(resultStr, pattern));
    CoTaskMemFree(result);
}

TEST_METHOD (VerifyRandomizerRegExZeroValue)
{
    CComPtr<IPowerRenameRegEx> renameRegEx;
    Assert::IsTrue(CPowerRenameRegEx::s_CreateInstance(&renameRegEx) == S_OK);
    DWORD flags = RandomizeItems | UseRegularExpressions;
    Assert::IsTrue(renameRegEx->PutFlags(flags) == S_OK);
    PWSTR result = nullptr;
    Assert::IsTrue(renameRegEx->PutSearchTerm(L"bar") == S_OK);
    Assert::IsTrue(renameRegEx->PutReplaceTerm(L"$1bar_${rstringalnum=0}") == S_OK);
    unsigned long index = {};
    Assert::IsTrue(renameRegEx->Replace(L"foobar", &result, index) == S_OK);
    Assert::AreEqual(L"foobar_", result);
    CoTaskMemFree(result);
}

TEST_METHOD (VerifyRandomizerRegExChar)
{
    CComPtr<IPowerRenameRegEx> renameRegEx;
    Assert::IsTrue(CPowerRenameRegEx::s_CreateInstance(&renameRegEx) == S_OK);
    DWORD flags = RandomizeItems | UseRegularExpressions;
    Assert::IsTrue(renameRegEx->PutFlags(flags) == S_OK);
    PWSTR result = nullptr;
    Assert::IsTrue(renameRegEx->PutSearchTerm(L"bar") == S_OK);
    Assert::IsTrue(renameRegEx->PutReplaceTerm(L"$1bar_${rstringalpha=9}") == S_OK);
    unsigned long index = {};
    Assert::IsTrue(renameRegEx->Replace(L"foobar", &result, index) == S_OK);
    std::wstring resultStr(result);
    std::wregex pattern(L"foobar_[A-Za-z]{9}");
    Assert::IsTrue(std::regex_match(resultStr, pattern));
    CoTaskMemFree(result);
}

TEST_METHOD (VerifyRandomizerRegExNum)
{
    CComPtr<IPowerRenameRegEx> renameRegEx;
    Assert::IsTrue(CPowerRenameRegEx::s_CreateInstance(&renameRegEx) == S_OK);
    DWORD flags = RandomizeItems | UseRegularExpressions;
    Assert::IsTrue(renameRegEx->PutFlags(flags) == S_OK);
    PWSTR result = nullptr;
    Assert::IsTrue(renameRegEx->PutSearchTerm(L"bar") == S_OK);
    Assert::IsTrue(renameRegEx->PutReplaceTerm(L"$1bar_${rstringdigit=9}") == S_OK);
    unsigned long index = {};
    Assert::IsTrue(renameRegEx->Replace(L"foobar", &result, index) == S_OK);
    std::wstring resultStr(result);
    std::wregex pattern(L"foobar_\\d{9}");
    Assert::IsTrue(std::regex_match(resultStr, pattern));
    CoTaskMemFree(result);
}

TEST_METHOD (VerifyRandomizerRegExUuid)
{
    CComPtr<IPowerRenameRegEx> renameRegEx;
    Assert::IsTrue(CPowerRenameRegEx::s_CreateInstance(&renameRegEx) == S_OK);
    DWORD flags = RandomizeItems | UseRegularExpressions;
    Assert::IsTrue(renameRegEx->PutFlags(flags) == S_OK);
    PWSTR result = nullptr;
    Assert::IsTrue(renameRegEx->PutSearchTerm(L"bar") == S_OK);
    Assert::IsTrue(renameRegEx->PutReplaceTerm(L"$1bar_${ruuidv4}") == S_OK);
    unsigned long index = {};
    Assert::IsTrue(renameRegEx->Replace(L"foobar", &result, index) == S_OK);
    std::wstring resultStr(result);
    std::wregex pattern(L"foobar_[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-4[0-9a-fA-F]{3}-[89aAbB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}");
    Assert::IsTrue(std::regex_match(resultStr, pattern));
    CoTaskMemFree(result);
}

TEST_METHOD (VerifyRandomizerRegExAllBackToBack)
{
    CComPtr<IPowerRenameRegEx> renameRegEx;
    Assert::IsTrue(CPowerRenameRegEx::s_CreateInstance(&renameRegEx) == S_OK);
    DWORD flags = RandomizeItems | UseRegularExpressions;
    Assert::IsTrue(renameRegEx->PutFlags(flags) == S_OK);
    PWSTR result = nullptr;
    Assert::IsTrue(renameRegEx->PutSearchTerm(L"bar") == S_OK);
    Assert::IsTrue(renameRegEx->PutReplaceTerm(L"$1bar_${rstringalnum=2}${rstringalpha=2}${rstringdigit=2}${ruuidv4}") == S_OK);
    unsigned long index = {};
    Assert::IsTrue(renameRegEx->Replace(L"foobar", &result, index) == S_OK);
    std::wstring resultStr(result);
    std::wregex pattern(L"foobar_\\w{2}[A-Za-z]{2}\\d{2}[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-4[0-9a-fA-F]{3}-[89aAbB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}");
    Assert::IsTrue(std::regex_match(resultStr, pattern));
    CoTaskMemFree(result);
}

#ifndef TESTS_PARTIAL
};
}
#endif
</file>

<file path="CppUnitTestInclude.h">
#pragma once
// Headers for CppUnitTest

// Suppressing 26466 - Don't use static_cast downcasts - in CppUnitTest.h
#pragma warning(push)
#pragma warning(disable : 26466)
#include "CppUnitTest.h"
#pragma warning(pop)
</file>

<file path="MockPowerRenameItem.cpp">
#include "pch.h"
#include "MockPowerRenameItem.h"

HRESULT CMockPowerRenameItem::CreateInstance(_In_opt_ PCWSTR path, _In_opt_ PCWSTR originalName, _In_ UINT depth, _In_ bool isFolder, _In_ SYSTEMTIME time, _Outptr_ IPowerRenameItem** ppItem)
{
    *ppItem = nullptr;
    CMockPowerRenameItem* newItem = new CMockPowerRenameItem();
    HRESULT hr = E_OUTOFMEMORY;
    if (newItem)
    {
        newItem->Init(path, originalName, depth, isFolder, time);
        hr = newItem->QueryInterface(IID_PPV_ARGS(ppItem));
        newItem->Release();
    }

    return hr;
}

void CMockPowerRenameItem::Init(_In_opt_ PCWSTR path, _In_opt_ PCWSTR originalName, _In_ UINT depth, _In_ bool isFolder, _In_ SYSTEMTIME time)
{
    if (path != nullptr)
    {
        SHStrDup(path, &m_path);
    }

    if (originalName != nullptr)
    {
        SHStrDup(originalName, &m_originalName);
    }

    m_depth = depth;
    m_isFolder = isFolder;
    m_time = time;
    m_isTimeParsed = true;
}
</file>

<file path="MockPowerRenameItem.h">
#pragma once
#include "pch.h"
#include <PowerRenameItem.h>
#include "srwlock.h"

class CMockPowerRenameItem :
    public CPowerRenameItem
{
public:
    static HRESULT CreateInstance(_In_opt_ PCWSTR path, _In_opt_ PCWSTR originalName, _In_ UINT depth, _In_ bool isFolder, _In_ SYSTEMTIME time, _Outptr_ IPowerRenameItem** ppItem);
    void Init(_In_opt_ PCWSTR path, _In_opt_ PCWSTR originalName, _In_ UINT depth, _In_ bool isFolder, _In_ SYSTEMTIME time);
};
</file>

<file path="MockPowerRenameManagerEvents.cpp">
#include "pch.h"
#include "MockPowerRenameManagerEvents.h"

// IUnknown
IFACEMETHODIMP CMockPowerRenameManagerEvents::QueryInterface(__in REFIID riid, __deref_out void** ppv)
{
    static const QITAB qit[] = {
        QITABENT(CMockPowerRenameManagerEvents, IPowerRenameManagerEvents),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

IFACEMETHODIMP_(ULONG)
CMockPowerRenameManagerEvents::AddRef()
{
    return InterlockedIncrement(&m_refCount);
}

IFACEMETHODIMP_(ULONG)
CMockPowerRenameManagerEvents::Release()
{
    long refCount = InterlockedDecrement(&m_refCount);
    if (refCount == 0)
    {
        delete this;
    }
    return refCount;
}

// IPowerRenameManagerEvents
IFACEMETHODIMP CMockPowerRenameManagerEvents::OnRename(_In_ IPowerRenameItem* pItem)
{
    m_itemRenamed = pItem;
    return S_OK;
}

IFACEMETHODIMP CMockPowerRenameManagerEvents::OnError(_In_ IPowerRenameItem* pItem)
{
    m_itemError = pItem;
    return S_OK;
}

IFACEMETHODIMP CMockPowerRenameManagerEvents::OnRegExStarted(_In_ DWORD /*threadId*/)
{
    m_regExStarted = true;
    return S_OK;
}

IFACEMETHODIMP CMockPowerRenameManagerEvents::OnRegExCanceled(_In_ DWORD /*threadId*/)
{
    m_regExCanceled = true;
    return S_OK;
}

IFACEMETHODIMP CMockPowerRenameManagerEvents::OnRegExCompleted(_In_ DWORD /*threadId*/)
{
    m_regExCompleted = true;
    return S_OK;
}

IFACEMETHODIMP CMockPowerRenameManagerEvents::OnRenameStarted()
{
    m_renameStarted = true;
    return S_OK;
}

IFACEMETHODIMP CMockPowerRenameManagerEvents::OnRenameCompleted(bool closeUIWindowAfterRenaming)
{
    m_renameCompleted = true;
    m_closeUIWindowAfterRenaming = closeUIWindowAfterRenaming;
    return S_OK;
}
</file>

<file path="MockPowerRenameManagerEvents.h">
#pragma once
#include <PowerRenameInterfaces.h>

class CMockPowerRenameManagerEvents :
    public IPowerRenameManagerEvents
{
public:
    CMockPowerRenameManagerEvents() :
        m_refCount(1)
    {
    }

    // IUnknown
    IFACEMETHODIMP QueryInterface(__in REFIID riid, __deref_out void** ppv);
    IFACEMETHODIMP_(ULONG)
    AddRef();
    IFACEMETHODIMP_(ULONG)
    Release();

    // IPowerRenameManagerEvents
    IFACEMETHODIMP OnItemAdded(_In_ IPowerRenameItem* renameItem);
    IFACEMETHODIMP OnUpdate(_In_ IPowerRenameItem* renameItem);
    IFACEMETHODIMP OnRename(_In_ IPowerRenameItem* renameItem);
    IFACEMETHODIMP OnError(_In_ IPowerRenameItem* renameItem);
    IFACEMETHODIMP OnRegExStarted(_In_ DWORD threadId);
    IFACEMETHODIMP OnRegExCanceled(_In_ DWORD threadId);
    IFACEMETHODIMP OnRegExCompleted(_In_ DWORD threadId);
    IFACEMETHODIMP OnRenameStarted();
    IFACEMETHODIMP OnRenameCompleted(bool closeUIWindowAfterRenaming);

    ~CMockPowerRenameManagerEvents()
    {
    }

    CComPtr<IPowerRenameItem> m_itemRenamed;
    CComPtr<IPowerRenameItem> m_itemError;
    bool m_regExStarted = false;
    bool m_regExCanceled = false;
    bool m_regExCompleted = false;
    bool m_renameStarted = false;
    bool m_renameCompleted = false;
    bool m_closeUIWindowAfterRenaming = false;
    long m_refCount = 0;
};
</file>

<file path="MockPowerRenameRegExEvents.cpp">
#include "pch.h"
#include "MockPowerRenameRegExEvents.h"

IFACEMETHODIMP_(ULONG)
CMockPowerRenameRegExEvents::AddRef()
{
    return InterlockedIncrement(&m_refCount);
}

IFACEMETHODIMP_(ULONG)
CMockPowerRenameRegExEvents::Release()
{
    long refCount = InterlockedDecrement(&m_refCount);

    if (refCount == 0)
    {
        delete this;
    }
    return refCount;
}

IFACEMETHODIMP CMockPowerRenameRegExEvents::QueryInterface(_In_ REFIID riid, _Outptr_ void** ppv)
{
    static const QITAB qit[] = {
        QITABENT(CMockPowerRenameRegExEvents, IPowerRenameRegExEvents),
        { 0 }
    };
    return QISearch(this, qit, riid, ppv);
}

IFACEMETHODIMP CMockPowerRenameRegExEvents::OnSearchTermChanged(_In_ PCWSTR searchTerm)
{
    CoTaskMemFree(m_searchTerm);
    m_searchTerm = nullptr;
    if (searchTerm != nullptr)
    {
        SHStrDup(searchTerm, &m_searchTerm);
    }
    return S_OK;
}

IFACEMETHODIMP CMockPowerRenameRegExEvents::OnReplaceTermChanged(_In_ PCWSTR replaceTerm)
{
    CoTaskMemFree(m_replaceTerm);
    m_replaceTerm = nullptr;
    if (replaceTerm != nullptr)
    {
        SHStrDup(replaceTerm, &m_replaceTerm);
    }
    return S_OK;
}

IFACEMETHODIMP CMockPowerRenameRegExEvents::OnFlagsChanged(_In_ DWORD flags)
{
    m_flags = flags;
    return S_OK;
}

IFACEMETHODIMP CMockPowerRenameRegExEvents::OnFileTimeChanged(_In_ SYSTEMTIME fileTime)
{
    m_fileTime = fileTime;
    return S_OK;
}

HRESULT CMockPowerRenameRegExEvents::s_CreateInstance(_Outptr_ IPowerRenameRegExEvents** ppsrree)
{
    *ppsrree = nullptr;
    CMockPowerRenameRegExEvents* psrree = new CMockPowerRenameRegExEvents();
    HRESULT hr = E_OUTOFMEMORY;
    if (psrree)
    {
        hr = psrree->QueryInterface(IID_PPV_ARGS(ppsrree));
        psrree->Release();
    }
    return hr;
}
</file>

<file path="MockPowerRenameRegExEvents.h">
#pragma once
#include <vector>
#include "srwlock.h"

#include "PowerRenameInterfaces.h"
class CMockPowerRenameRegExEvents :
    public IPowerRenameRegExEvents
{
public:
    // IUnknown
    IFACEMETHODIMP QueryInterface(_In_ REFIID iid, _Outptr_ void** resultInterface);
    IFACEMETHODIMP_(ULONG)
    AddRef();
    IFACEMETHODIMP_(ULONG)
    Release();

    // IPowerRenameRegExEvents
    IFACEMETHODIMP OnSearchTermChanged(_In_ PCWSTR searchTerm);
    IFACEMETHODIMP OnReplaceTermChanged(_In_ PCWSTR replaceTerm);
    IFACEMETHODIMP OnFlagsChanged(_In_ DWORD flags);
    IFACEMETHODIMP OnFileTimeChanged(_In_ SYSTEMTIME fileTime);

    static HRESULT s_CreateInstance(_Outptr_ IPowerRenameRegExEvents** ppsrree);

    CMockPowerRenameRegExEvents() :
        m_refCount(1)
    {
    }

    ~CMockPowerRenameRegExEvents()
    {
        CoTaskMemFree(m_searchTerm);
        CoTaskMemFree(m_replaceTerm);
    }

    PWSTR m_searchTerm = nullptr;
    PWSTR m_replaceTerm = nullptr;
    DWORD m_flags = 0;
    SYSTEMTIME m_fileTime = { 0 };
    long m_refCount;
};
</file>

<file path="pch.cpp">
#include "pch.h"
</file>

<file path="pch.h">
#pragma once

#define NOMINMAX
#include "targetver.h"

#include <atlbase.h>
#include "CppUnitTestInclude.h"
</file>

<file path="PowerRenameManagerTests.cpp">
#include "pch.h"
#include <PowerRenameInterfaces.h>
#include <PowerRenameManager.h>
#include <PowerRenameItem.h>
#include "MockPowerRenameItem.h"
#include "MockPowerRenameManagerEvents.h"
#include "TestFileHelper.h"
#include "Helpers.h"

#define DEFAULT_FLAGS 0

using namespace Microsoft::VisualStudio::CppUnitTestFramework;

EXTERN_C IMAGE_DOS_HEADER __ImageBase;

#define HINST_THISCOMPONENT ((HINSTANCE)&__ImageBase)

HINSTANCE g_hostHInst = HINST_THISCOMPONENT;

namespace PowerRenameManagerTests
{
    TEST_CLASS (SimpleTests)
    {
    public:
        struct rename_pairs
        {
            std::wstring originalName;
            std::wstring newName;
            bool isFile;
            bool shouldRename;
            int depth;
        };

        void RenameHelper(_In_ rename_pairs * renamePairs, _In_ int numPairs, _In_ std::wstring searchTerm, _In_ std::wstring replaceTerm, SYSTEMTIME fileTime, _In_ DWORD flags)
        {
            // Create a single item (in a temp directory) and verify rename works as expected
            CTestFileHelper testFileHelper;
            for (int i = 0; i < numPairs; i++)
            {
                if (renamePairs[i].isFile)
                {
                    Assert::IsTrue(testFileHelper.AddFile(renamePairs[i].originalName));
                }
                else
                {
                    Assert::IsTrue(testFileHelper.AddFolder(renamePairs[i].originalName));
                }
            }

            CComPtr<IPowerRenameManager> mgr;
            Assert::IsTrue(CPowerRenameManager::s_CreateInstance(&mgr) == S_OK);
            CMockPowerRenameManagerEvents* mockMgrEvents = new CMockPowerRenameManagerEvents();
            CComPtr<IPowerRenameManagerEvents> mgrEvents;
            Assert::IsTrue(mockMgrEvents->QueryInterface(IID_PPV_ARGS(&mgrEvents)) == S_OK);
            DWORD cookie = 0;
            Assert::IsTrue(mgr->Advise(mgrEvents, &cookie) == S_OK);

            for (int i = 0; i < numPairs; i++)
            {
                CComPtr<IPowerRenameItem> item;
                CMockPowerRenameItem::CreateInstance(testFileHelper.GetFullPath(renamePairs[i].originalName).c_str(),
                                                     renamePairs[i].originalName.c_str(),
                                                     renamePairs[i].depth,
                                                     !renamePairs[i].isFile,
                                                     fileTime,
                                                     &item);

                int itemId = 0;
                Assert::IsTrue(item->GetId(&itemId) == S_OK);
                mgr->AddItem(item);
            }

            // TODO: Setup match and replace parameters
            CComPtr<IPowerRenameRegEx> renRegEx;
            Assert::IsTrue(mgr->GetRenameRegEx(&renRegEx) == S_OK);
            renRegEx->PutFlags(flags);
            renRegEx->PutSearchTerm(searchTerm.c_str());
            renRegEx->PutReplaceTerm(replaceTerm.c_str());

            // Perform the rename
            bool replaceSuccess = false;
            for (int step = 0; step < 20; step++)
            {
                replaceSuccess = mgr->Rename(0, true) == S_OK;
                if (replaceSuccess)
                {
                    break;
                }
                Sleep(10);
            }

            Assert::IsTrue(replaceSuccess);

            std::vector<std::wstring> shouldRename = { L"not ", L"" };

            // Verify the rename occurred
            for (int i = 0; i < numPairs; i++)
            {
                Assert::IsTrue(testFileHelper.PathExistsCaseSensitive(renamePairs[i].originalName) == !renamePairs[i].shouldRename, 
                               (std::wstring(L"The path: [" +  renamePairs[i].originalName + L"] should ") + shouldRename[!renamePairs[i].shouldRename] + L"exist.").c_str());
                Assert::IsTrue(testFileHelper.PathExistsCaseSensitive(renamePairs[i].newName) == renamePairs[i].shouldRename,
                               (std::wstring(L"The path: [" + renamePairs[i].newName + L"] should ") + shouldRename[renamePairs[i].shouldRename] + L"exist.").c_str());
            }

            Assert::IsTrue(mgr->Shutdown() == S_OK);

            mockMgrEvents->Release();
        }
        TEST_METHOD (CreateTest)
        {
            CComPtr<IPowerRenameManager> mgr;
            Assert::IsTrue(CPowerRenameManager::s_CreateInstance(&mgr) == S_OK);
        }

        TEST_METHOD (CreateAndShutdownTest)
        {
            CComPtr<IPowerRenameManager> mgr;
            Assert::IsTrue(CPowerRenameManager::s_CreateInstance(&mgr) == S_OK);
            Assert::IsTrue(mgr->Shutdown() == S_OK);
        }

        TEST_METHOD (AddItemTest)
        {
            CComPtr<IPowerRenameManager> mgr;
            Assert::IsTrue(CPowerRenameManager::s_CreateInstance(&mgr) == S_OK);
            CComPtr<IPowerRenameItem> item;
            CMockPowerRenameItem::CreateInstance(L"foo", L"foo", 0, false, SYSTEMTIME{ 0 }, &item);
            mgr->AddItem(item);
            Assert::IsTrue(mgr->Shutdown() == S_OK);
        }

        TEST_METHOD (VerifyRenameManagerEvents)
        {
            CComPtr<IPowerRenameManager> mgr;
            Assert::IsTrue(CPowerRenameManager::s_CreateInstance(&mgr) == S_OK);
            CMockPowerRenameManagerEvents* mockMgrEvents = new CMockPowerRenameManagerEvents();
            CComPtr<IPowerRenameManagerEvents> mgrEvents;
            Assert::IsTrue(mockMgrEvents->QueryInterface(IID_PPV_ARGS(&mgrEvents)) == S_OK);
            DWORD cookie = 0;
            Assert::IsTrue(mgr->Advise(mgrEvents, &cookie) == S_OK);
            CComPtr<IPowerRenameItem> item;
            CMockPowerRenameItem::CreateInstance(L"foo", L"foo", 0, false, SYSTEMTIME{ 0 }, &item);
            int itemId = 0;
            Assert::IsTrue(item->GetId(&itemId) == S_OK);
            mgr->AddItem(item);

            Assert::IsTrue(mgr->Shutdown() == S_OK);

            mockMgrEvents->Release();
        }

        TEST_METHOD (VerifySingleRename)
        {
            // Create a single item and verify rename works as expected
            rename_pairs renamePairs[] = {
                { L"foo.txt", L"bar.txt", true, true }
            };

            RenameHelper(renamePairs, ARRAYSIZE(renamePairs), L"foo", L"bar", SYSTEMTIME{ 2020, 7, 3, 22, 15, 6, 42, 453 }, DEFAULT_FLAGS);
        }

        TEST_METHOD (VerifyMultiRename)
        {
            // Create a single item and verify rename works as expected
            rename_pairs renamePairs[] = {
                { L"foo1.txt", L"bar1.txt", true, true, 0 },
                { L"foo2.txt", L"bar2.txt", true, true, 0 },
                { L"foo3.txt", L"bar3.txt", true, true, 0 },
                { L"foo4.txt", L"bar4.txt", true, true, 0 },
                { L"foo5.txt", L"bar5.txt", true, true, 0 },
                { L"baa.txt", L"baa_norename.txt", true, false, 0 }
            };

            RenameHelper(renamePairs, ARRAYSIZE(renamePairs), L"foo", L"bar", SYSTEMTIME{ 2020, 7, 3, 22, 15, 6, 42, 453 }, DEFAULT_FLAGS);
        }

        TEST_METHOD (VerifyFilesOnlyRename)
        {
            // Verify only files are renamed when folders match too
            rename_pairs renamePairs[] = {
                { L"foo.txt", L"bar.txt", true, true, 0 },
                { L"foo", L"foo_norename", false, false, 0 }
            };

            RenameHelper(renamePairs, ARRAYSIZE(renamePairs), L"foo", L"bar", SYSTEMTIME{ 2020, 7, 3, 22, 15, 6, 42, 453 }, DEFAULT_FLAGS | ExcludeFolders);
        }

        TEST_METHOD (VerifyFoldersOnlyRename)
        {
            // Verify only folders are renamed when files match too
            rename_pairs renamePairs[] = {
                { L"foo.txt", L"foo_norename.txt", true, false, 0 },
                { L"foo", L"bar", false, true, 0 }
            };

            RenameHelper(renamePairs, ARRAYSIZE(renamePairs), L"foo", L"bar", SYSTEMTIME{ 2020, 7, 3, 22, 15, 6, 42, 453 }, DEFAULT_FLAGS | ExcludeFiles);
        }

        TEST_METHOD (VerifyFileNameOnlyRename)
        {
            // Verify only file name is renamed, not extension
            rename_pairs renamePairs[] = {
                { L"foo.foo", L"bar.foo", true, true, 0 },
                { L"test.foo", L"test.foo_norename", true, false, 0 }
            };

            RenameHelper(renamePairs, ARRAYSIZE(renamePairs), L"foo", L"bar", SYSTEMTIME{ 2020, 7, 3, 22, 15, 6, 42, 453 }, DEFAULT_FLAGS | NameOnly);
        }

        TEST_METHOD (VerifyFileExtensionOnlyRename)
        {
            // Verify only file extension is renamed, not name
            rename_pairs renamePairs[] = {
                { L"foo.foo", L"foo.bar", true, true, 0 },
                { L"test.foo", L"test.bar", true, true, 0 }
            };

            RenameHelper(renamePairs, ARRAYSIZE(renamePairs), L"foo", L"bar", SYSTEMTIME{ 2020, 7, 3, 22, 15, 6, 42, 453 }, DEFAULT_FLAGS | ExtensionOnly);
        }

        TEST_METHOD (VerifySubFoldersRename)
        {
            // Verify subfolders do not get renamed
            rename_pairs renamePairs[] = {
                { L"foo1", L"bar1", false, true, 0 },
                { L"foo2", L"foo2_norename", false, false, 1 }
            };

            RenameHelper(renamePairs, ARRAYSIZE(renamePairs), L"foo", L"bar", SYSTEMTIME{ 2020, 7, 3, 22, 15, 6, 42, 453 }, DEFAULT_FLAGS | ExcludeSubfolders);
        }

        TEST_METHOD (VerifyUppercaseTransform)
        {
            rename_pairs renamePairs[] = {
                { L"foo", L"BAR", true, true, 0 },
                { L"foo.test", L"BAR.TEST", true, true, 0 },
                { L"TEST", L"TEST_norename", true, false, 0 }
            };

            RenameHelper(renamePairs, ARRAYSIZE(renamePairs), L"foo", L"bar", SYSTEMTIME{ 2020, 7, 3, 22, 15, 6, 42, 453 }, DEFAULT_FLAGS | Uppercase);
        }

        TEST_METHOD (VerifyLowercaseTransform)
        {
            rename_pairs renamePairs[] = {
                { L"Foo", L"bar", false, true, 0 },
                { L"Foo.teST", L"bar.test", false, true, 0 },
                { L"test", L"test_norename", false, false, 0 }
            };

            RenameHelper(renamePairs, ARRAYSIZE(renamePairs), L"foo", L"bar", SYSTEMTIME{ 2020, 7, 3, 22, 15, 6, 42, 453 }, DEFAULT_FLAGS | Lowercase);
        }

        TEST_METHOD (VerifyTitlecaseTransform)
        {
            rename_pairs renamePairs[] = {
                { L"foo And The To", L"Bar and the To", false, true, 0 },
                { L"foo And The To.txt", L"Bar and the To.txt", true, true, 0 },
                { L"Test", L"Test_norename", false, false, 0 }
            };

            RenameHelper(renamePairs, ARRAYSIZE(renamePairs), L"foo", L"bar", SYSTEMTIME{ 2020, 7, 3, 22, 15, 6, 42, 453 }, DEFAULT_FLAGS | Titlecase);
        }      

        TEST_METHOD (VerifyTitlecaseWithApostropheTransform)
        {
            rename_pairs renamePairs[] = {
                { L"the foo i'll and i've you're dogs' the i'd it's i'm don't to y'all", L"The Bar I'll and I've You're Dogs' the I'd It's I'm Don't to Y'all", false, true, 0 },
                { L"'the 'foo' 'i'll' and i've you're dogs' the 'i'd' it's i'm don't to y'all.txt", L"'The 'Bar' 'I'll' and I've You're Dogs' the 'I'd' It's I'm Don't to Y'all.txt", true, true, 0 },
                { L"Test", L"Test_norename", false, false, 0 }
            };

            RenameHelper(renamePairs, ARRAYSIZE(renamePairs), L"foo", L"bar", SYSTEMTIME{ 2020, 7, 3, 22, 15, 6, 42, 453 }, DEFAULT_FLAGS | Titlecase);
        }

        TEST_METHOD (VerifyCapitalizedTransform)
        {
            rename_pairs renamePairs[] = {
                { L"foo and the to", L"Bar And The To", false, true, 0 },
                { L"Test", L"Test_norename", false, false, 0 }
            };

            RenameHelper(renamePairs, ARRAYSIZE(renamePairs), L"foo", L"bar", SYSTEMTIME{ 2020, 7, 3, 22, 15, 6, 42, 453 }, DEFAULT_FLAGS | Capitalized);
        }

        TEST_METHOD (VerifyCapitalizedWithApostropheTransform)
        {
            rename_pairs renamePairs[] = {
                { L"foo i'll and i've you're dogs' the i'd it's i'm don't to y'all", L"Bar I'll And I've You're Dogs' The I'd It's I'm Don't To Y'all", false, true, 0 },
                { L"'foo i'll 'and' i've you're dogs' the i'd it's i'm don't to y'all.txt", L"'Bar I'll 'And' I've You're Dogs' The I'd It's I'm Don't To Y'all.txt", true, true, 0 },
                { L"Test", L"Test_norename", false, false, 0 }
            };

            RenameHelper(renamePairs, ARRAYSIZE(renamePairs), L"foo", L"bar", SYSTEMTIME{ 2020, 7, 3, 22, 15, 6, 42, 453 }, DEFAULT_FLAGS | Capitalized);
        }

        TEST_METHOD (VerifyNameOnlyTransform)
        {
            rename_pairs renamePairs[] = {
                { L"foo.foo", L"BAR.foo", true, true, 0 },
                { L"foo.txt", L"BAR.TXT", false, true, 0 },
                { L"TEST", L"TEST_norename", false, false, 1 }
            };

            RenameHelper(renamePairs, ARRAYSIZE(renamePairs), L"foo", L"bar", SYSTEMTIME{ 2020, 7, 3, 22, 15, 6, 42, 453 }, DEFAULT_FLAGS | Uppercase | NameOnly);
        }

        TEST_METHOD (VerifyExtensionOnlyTransform)
        {
            rename_pairs renamePairs[] = {
                { L"foo.FOO", L"foo.bar", true, true, 0 },
                { L"bar.FOO", L"bar.FOO_norename", false, false, 0 },
                { L"foo.bar", L"foo.bar_norename", true, false, 0 }
            };

            RenameHelper(renamePairs, ARRAYSIZE(renamePairs), L"foo", L"bar", SYSTEMTIME{ 2020, 7, 3, 22, 15, 6, 42, 453 }, DEFAULT_FLAGS | Lowercase | ExtensionOnly);
        }

        TEST_METHOD (VerifyFileAttributesNoPadding)
        {
            rename_pairs renamePairs[] = {
                { L"foo", L"bar20-7-22-15-6-42-4", true, true, 0 },
            };

            RenameHelper(renamePairs, ARRAYSIZE(renamePairs), L"foo", L"bar$YY-$M-$D-$h-$m-$s-$f", SYSTEMTIME{ 2020, 7, 3, 22, 15, 6, 42, 453 }, DEFAULT_FLAGS);
        }

        TEST_METHOD (VerifyFileAttributesPadding)
        {
            rename_pairs renamePairs[] = {
                { L"foo", L"bar2020-07-22-15-06-42-453", true, true, 0 },
            };

            RenameHelper(renamePairs, ARRAYSIZE(renamePairs), L"foo", L"bar$YYYY-$MM-$DD-$hh-$mm-$ss-$fff", SYSTEMTIME{ 2020, 7, 3, 22, 15, 6, 42, 453 }, DEFAULT_FLAGS);
        }

        TEST_METHOD (VerifyFileAttributesMonthAndDayNames)
        {
            std::locale::global(std::locale(""));
            SYSTEMTIME fileTime = { 2020, 1, 3, 1, 15, 6, 42, 453 };
            wchar_t localeName[LOCALE_NAME_MAX_LENGTH];
            wchar_t result[MAX_PATH] = L"bar";
            wchar_t formattedDate[MAX_PATH];
            if (GetUserDefaultLocaleName(localeName, LOCALE_NAME_MAX_LENGTH) == 0)
                StringCchCopy(localeName, LOCALE_NAME_MAX_LENGTH, L"en_US");

            GetDateFormatEx(localeName, NULL, &fileTime, L"MMM", formattedDate, MAX_PATH, NULL);
            formattedDate[0] = towupper(formattedDate[0]);
            StringCchPrintf(result, MAX_PATH, TEXT("%s%s"), result, formattedDate);

            GetDateFormatEx(localeName, NULL, &fileTime, L"MMMM", formattedDate, MAX_PATH, NULL);
            formattedDate[0] = towupper(formattedDate[0]);
            StringCchPrintf(result, MAX_PATH, TEXT("%s-%s"), result, formattedDate);

            GetDateFormatEx(localeName, NULL, &fileTime, L"ddd", formattedDate, MAX_PATH, NULL);
            formattedDate[0] = towupper(formattedDate[0]);
            StringCchPrintf(result, MAX_PATH, TEXT("%s-%s"), result, formattedDate);

            GetDateFormatEx(localeName, NULL, &fileTime, L"dddd", formattedDate, MAX_PATH, NULL);
            formattedDate[0] = towupper(formattedDate[0]);
            StringCchPrintf(result, MAX_PATH, TEXT("%s-%s"), result, formattedDate);

            rename_pairs renamePairs[] = {
                { L"foo", result, true, true, 0 },
            };

            RenameHelper(renamePairs, ARRAYSIZE(renamePairs), L"foo", L"bar$MMM-$MMMM-$DDD-$DDDD", SYSTEMTIME{ 2020, 1, 3, 1, 15, 6, 42, 453 }, DEFAULT_FLAGS);
        }
    };
}
</file>

<file path="PowerRenameRegExBoostTests.cpp">
#include "pch.h"
#include "powerrename/lib/Settings.h"
#include <PowerRenameInterfaces.h>
#include <PowerRenameRegEx.h>
#include "MockPowerRenameRegExEvents.h"

using namespace Microsoft::VisualStudio::CppUnitTestFramework;

namespace PowerRenameRegExBoostTests
{
    TEST_CLASS(SimpleTests)
    {
    public:
TEST_CLASS_INITIALIZE(ClassInitialize)
{
    CSettingsInstance().SetUseBoostLib(true);
}

TEST_CLASS_CLEANUP(ClassCleanup)
{
    CSettingsInstance().SetUseBoostLib(false);
}

#define TESTS_PARTIAL
#include "CommonRegExTests.h"

TEST_METHOD(VerifyMatchAllWildcardUseRegEx)
{
    CComPtr<IPowerRenameRegEx> renameRegEx;
    Assert::IsTrue(CPowerRenameRegEx::s_CreateInstance(&renameRegEx) == S_OK);
    DWORD flags = MatchAllOccurrences | UseRegularExpressions;
    Assert::IsTrue(renameRegEx->PutFlags(flags) == S_OK);

    // This differs from the Standard Library: .* has two matches (all and nothing).
    SearchReplaceExpected sreTable[] = {
        //search, replace, test, result
        { L".*", L"Foo", L"AAAAAA", L"FooFoo" },
        { L".+", L"Foo", L"AAAAAA", L"Foo" },
    };

    for (int i = 0; i < ARRAYSIZE(sreTable); i++)
    {
        PWSTR result = nullptr;
        Assert::IsTrue(renameRegEx->PutSearchTerm(sreTable[i].search) == S_OK);
        Assert::IsTrue(renameRegEx->PutReplaceTerm(sreTable[i].replace) == S_OK);
        unsigned long index = {};
        Assert::IsTrue(renameRegEx->Replace(sreTable[i].test, &result, index) == S_OK);
        Assert::IsTrue(wcscmp(result, sreTable[i].expected) == 0);
        CoTaskMemFree(result);
    }
}

TEST_METHOD(VerifyReplaceFirstWildCardUseRegexMatchAllOccurrences)
{
    // This differs from the Standard Library: .* has two matches (all and nothing).
    SearchReplaceExpected sreTable[] = {
        //search, replace, test, result
        { L".*", L"Foo", L"AAAAAA", L"FooFoo" },
        { L".+", L"Foo", L"AAAAAA", L"Foo" },
    };
    VerifyReplaceFirstWildcard(sreTable, ARRAYSIZE(sreTable), UseRegularExpressions | MatchAllOccurrences);
}

TEST_METHOD(VerifyHandleCapturingGroups)
{
    // This differs from the Standard Library: Boost does not recognize $123 as $1 and "23".
    // To use a capturing group followed by numbers as replacement curly braces are needed.
    CComPtr<IPowerRenameRegEx> renameRegEx;
    Assert::IsTrue(CPowerRenameRegEx::s_CreateInstance(&renameRegEx) == S_OK);
    DWORD flags = MatchAllOccurrences | UseRegularExpressions | CaseSensitive;
    Assert::IsTrue(renameRegEx->PutFlags(flags) == S_OK);

    SearchReplaceExpected sreTable[] = {
        //search, replace, test, result
        { L"(foo)(bar)", L"$1_$002_$223_$001021_$00001", L"foobar", L"foo_$002__$001021_$00001" },
        { L"(foo)(bar)", L"$1_$002_${2}23_$001021_$00001", L"foobar", L"foo_$002_bar23_$001021_$00001" },
        { L"(foo)(bar)", L"_$1$2_$123$040", L"foobar", L"_foobar_$040" },
        { L"(foo)(bar)", L"_$1$2_${1}23$040", L"foobar", L"_foobar_foo23$040" },
        { L"(foo)(bar)", L"$$$1", L"foobar", L"$foo" },
        { L"(foo)(bar)", L"$$1", L"foobar", L"$1" },
        { L"(foo)(bar)", L"$12", L"foobar", L"" },
        { L"(foo)(bar)", L"${1}2", L"foobar", L"foo2" },
        { L"(foo)(bar)", L"$10", L"foobar", L"" },
        { L"(foo)(bar)", L"${1}0", L"foobar", L"foo0" },
        { L"(foo)(bar)", L"$01", L"foobar", L"$01" },
        { L"(foo)(bar)", L"$$$11", L"foobar", L"$" },
        { L"(foo)(bar)", L"$$${1}1", L"foobar", L"$foo1" },
        { L"(foo)(bar)", L"$$$$113a", L"foobar", L"$$113a" },
    };

    for (int i = 0; i < ARRAYSIZE(sreTable); i++)
    {
        PWSTR result = nullptr;
        Assert::IsTrue(renameRegEx->PutSearchTerm(sreTable[i].search) == S_OK);
        Assert::IsTrue(renameRegEx->PutReplaceTerm(sreTable[i].replace) == S_OK);
        unsigned long index = {};
        Assert::IsTrue(renameRegEx->Replace(sreTable[i].test, &result, index) == S_OK);
        Assert::IsTrue(wcscmp(result, sreTable[i].expected) == 0);
        CoTaskMemFree(result);
    }
}

TEST_METHOD(VerifyLookbehind)
{
    SearchReplaceExpected sreTable[] = {
        //search, replace, test, result
        { L"(?<=E12).*", L"Foo", L"AAE12BBB", L"AAE12Foo" },
        { L"(?<=E12).+", L"Foo", L"AAE12BBB", L"AAE12Foo" },
        { L"(?<=E\\d\\d).+", L"Foo", L"AAE12BBB", L"AAE12Foo" },
        { L"(?<!E12).*", L"Foo", L"AAE12BBB", L"Foo" },
        { L"(?<!E12).+", L"Foo", L"AAE12BBB", L"Foo" },
        { L"(?<!E\\d\\d).+", L"Foo", L"AAE12BBB", L"Foo" },
    };

    CComPtr<IPowerRenameRegEx> renameRegEx;
    Assert::IsTrue(CPowerRenameRegEx::s_CreateInstance(&renameRegEx) == S_OK);
    Assert::IsTrue(renameRegEx->PutFlags(UseRegularExpressions) == S_OK);

    for (int i = 0; i < ARRAYSIZE(sreTable); i++)
    {
        PWSTR result = nullptr;
        Assert::IsTrue(renameRegEx->PutSearchTerm(sreTable[i].search) == S_OK);
        Assert::IsTrue(renameRegEx->PutReplaceTerm(sreTable[i].replace) == S_OK);
        unsigned long index = {};
        Assert::IsTrue(renameRegEx->Replace(sreTable[i].test, &result, index) == S_OK);
        Assert::IsTrue(wcscmp(result, sreTable[i].expected) == 0);
        CoTaskMemFree(result);
    }
}

TEST_METHOD (Verify12and24HourTimeFormats)
{
    CComPtr<IPowerRenameRegEx> renameRegEx;
    Assert::IsTrue(CPowerRenameRegEx::s_CreateInstance(&renameRegEx) == S_OK);
    DWORD flags = MatchAllOccurrences | UseRegularExpressions;
    Assert::IsTrue(renameRegEx->PutFlags(flags) == S_OK);

    struct TimeTestCase {
        SYSTEMTIME time;        // Input time
        PCWSTR formatString;    // Format pattern
        PCWSTR expectedResult;  // Expected output
        PCWSTR description;     // Description of what we're testing
    };

    struct TimeTestCase testCases[] = {
        // Midnight (00:00 / 12:00 AM)
        { { 2025, 4, 4, 10, 0, 0, 0, 0 }, L"[$hh:$mm] [$H:$mm $tt]", L"[00:00] [12:00 am]", L"Midnight formatting" },

        // Noon (12:00 / 12:00 PM)
        { { 2025, 4, 4, 10, 12, 0, 0, 0 }, L"[$hh:$mm] [$H:$mm $tt]", L"[12:00] [12:00 pm]", L"Noon formatting" },

        // 1:05 AM
        { { 2025, 4, 4, 10, 1, 5, 0, 0 }, L"[$h:$m] [$H:$m $tt] [$hh:$mm] [$HH:$mm $TT]", 
          L"[1:5] [1:5 am] [01:05] [01:05 AM]", L"1 AM with various formats" },

        // 11 PM
        { { 2025, 4, 4, 10, 23, 45, 0, 0 }, L"[$h:$m] [$H:$m $tt] [$hh:$mm] [$HH:$mm $TT]", 
          L"[23:45] [11:45 pm] [23:45] [11:45 PM]", L"11 PM with various formats" },

        // Mixed formats in complex pattern
        { { 2025, 4, 4, 10, 14, 30, 0, 0 }, L"Date: $YYYY-$MM-$DD Time: $hh:$mm (24h) / $H:$mm $tt (12h)", 
          L"Date: 2025-04-10 Time: 14:30 (24h) / 2:30 pm (12h)", L"Complex combined format" },
    };

    for (int i = 0; i < ARRAYSIZE(testCases); i++)
    {
        PWSTR result = nullptr;
        Assert::IsTrue(renameRegEx->PutSearchTerm(L"test") == S_OK);
        Assert::IsTrue(renameRegEx->PutReplaceTerm(testCases[i].formatString) == S_OK);
        Assert::IsTrue(renameRegEx->PutFileTime(testCases[i].time) == S_OK);
        unsigned long index = {};
        Assert::IsTrue(renameRegEx->Replace(L"test", &result, index) == S_OK);
        Assert::IsTrue(wcscmp(result, testCases[i].expectedResult) == 0, 
                      (std::wstring(L"Failed test case: ") + testCases[i].description).c_str());
        CoTaskMemFree(result);
    }
}
};
}
</file>

<file path="PowerRenameRegExTests.cpp">
#include "pch.h"
#include "powerrename/lib/Settings.h"
#include <PowerRenameInterfaces.h>
#include <PowerRenameRegEx.h>
#include "MockPowerRenameRegExEvents.h"

using namespace Microsoft::VisualStudio::CppUnitTestFramework;

namespace PowerRenameRegExTests
{
    TEST_CLASS(SimpleTests){
        public:
TEST_CLASS_INITIALIZE(ClassInitialize)
{
    CSettingsInstance().SetUseBoostLib(false);
}

#define TESTS_PARTIAL
#include "CommonRegExTests.h"

TEST_METHOD(VerifyMatchAllWildcardUseRegEx)
{
    CComPtr<IPowerRenameRegEx> renameRegEx;
    Assert::IsTrue(CPowerRenameRegEx::s_CreateInstance(&renameRegEx) == S_OK);
    DWORD flags = MatchAllOccurrences | UseRegularExpressions;
    Assert::IsTrue(renameRegEx->PutFlags(flags) == S_OK);

    SearchReplaceExpected sreTable[] = {
        { L".*", L"Foo", L"AAAAAA", L"Foo" },
    };

    for (int i = 0; i < ARRAYSIZE(sreTable); i++)
    {
        PWSTR result = nullptr;
        Assert::IsTrue(renameRegEx->PutSearchTerm(sreTable[i].search) == S_OK);
        Assert::IsTrue(renameRegEx->PutReplaceTerm(sreTable[i].replace) == S_OK);
        unsigned long index = {};
        Assert::IsTrue(renameRegEx->Replace(sreTable[i].test, &result, index) == S_OK);
        Assert::IsTrue(wcscmp(result, sreTable[i].expected) == 0);
        CoTaskMemFree(result);
    }
}

TEST_METHOD(VerifyReplaceFirstWildCardUseRegexMatchAllOccurrences)
{
    SearchReplaceExpected sreTable[] = {
        //search, replace, test, result
        { L".*", L"Foo", L"AAAAAA", L"Foo" },
    };
    VerifyReplaceFirstWildcard(sreTable, ARRAYSIZE(sreTable), UseRegularExpressions | MatchAllOccurrences);
}

TEST_METHOD(VerifyHandleCapturingGroups)
{
    CComPtr<IPowerRenameRegEx> renameRegEx;
    Assert::IsTrue(CPowerRenameRegEx::s_CreateInstance(&renameRegEx) == S_OK);
    DWORD flags = MatchAllOccurrences | UseRegularExpressions | CaseSensitive;
    Assert::IsTrue(renameRegEx->PutFlags(flags) == S_OK);

    SearchReplaceExpected sreTable[] = {
        //search, replace, test, result
        { L"(foo)(bar)", L"$1_$002_$223_$001021_$00001", L"foobar", L"foo_$002_bar23_$001021_$00001" },
        { L"(foo)(bar)", L"_$1$2_$123$040", L"foobar", L"_foobar_foo23$040" },
        { L"(foo)(bar)", L"$$$1", L"foobar", L"$foo" },
        { L"(foo)(bar)", L"$$1", L"foobar", L"$1" },
        { L"(foo)(bar)", L"$12", L"foobar", L"foo2" },
        { L"(foo)(bar)", L"$10", L"foobar", L"foo0" },
        { L"(foo)(bar)", L"$01", L"foobar", L"$01" },
        { L"(foo)(bar)", L"$$$11", L"foobar", L"$foo1" },
        { L"(foo)(bar)", L"$$$$113a", L"foobar", L"$$113a" },
    };

    for (int i = 0; i < ARRAYSIZE(sreTable); i++)
    {
        PWSTR result = nullptr;
        Assert::IsTrue(renameRegEx->PutSearchTerm(sreTable[i].search) == S_OK);
        Assert::IsTrue(renameRegEx->PutReplaceTerm(sreTable[i].replace) == S_OK);
        unsigned long index = {};
        Assert::IsTrue(renameRegEx->Replace(sreTable[i].test, &result, index) == S_OK);
        Assert::IsTrue(wcscmp(result, sreTable[i].expected) == 0);
        CoTaskMemFree(result);
    }
}

TEST_METHOD (VerifyFileAttributesNoPadding)
{
    CComPtr<IPowerRenameRegEx> renameRegEx;
    Assert::IsTrue(CPowerRenameRegEx::s_CreateInstance(&renameRegEx) == S_OK);
    DWORD flags = MatchAllOccurrences | UseRegularExpressions ;
    SYSTEMTIME fileTime = SYSTEMTIME{ 2020, 7, 3, 22, 15, 6, 42, 453 };
    Assert::IsTrue(renameRegEx->PutFlags(flags) == S_OK);

    SearchReplaceExpected sreTable[] = {
        //search, replace, test, result
        { L"foo", L"bar$YY-$M-$D-$h-$m-$s-$f", L"foo", L"bar20-7-22-15-6-42-4" },
    };

    for (int i = 0; i < ARRAYSIZE(sreTable); i++)
    {
        PWSTR result = nullptr;
        Assert::IsTrue(renameRegEx->PutSearchTerm(sreTable[i].search) == S_OK);
        Assert::IsTrue(renameRegEx->PutReplaceTerm(sreTable[i].replace) == S_OK);
        Assert::IsTrue(renameRegEx->PutFileTime(fileTime) == S_OK);
        unsigned long index = {};
        Assert::IsTrue(renameRegEx->Replace(sreTable[i].test, &result, index) == S_OK);
        Assert::IsTrue(wcscmp(result, sreTable[i].expected) == 0);
        CoTaskMemFree(result);
    }
}

TEST_METHOD (VerifyFileAttributesPadding)
{
    CComPtr<IPowerRenameRegEx> renameRegEx;
    Assert::IsTrue(CPowerRenameRegEx::s_CreateInstance(&renameRegEx) == S_OK);
    DWORD flags = MatchAllOccurrences | UseRegularExpressions;
    Assert::IsTrue(renameRegEx->PutFlags(flags) == S_OK);
    SYSTEMTIME fileTime = SYSTEMTIME{ 2020, 7, 3, 22, 15, 6, 42, 453 };
    SearchReplaceExpected sreTable[] = {
        //search, replace, test, result
        { L"foo", L"bar$YYYY-$MM-$DD-$hh-$mm-$ss-$fff", L"foo", L"bar2020-07-22-15-06-42-453" },
    };

    for (int i = 0; i < ARRAYSIZE(sreTable); i++)
    {
        PWSTR result = nullptr;
        Assert::IsTrue(renameRegEx->PutSearchTerm(sreTable[i].search) == S_OK);
        Assert::IsTrue(renameRegEx->PutReplaceTerm(sreTable[i].replace) == S_OK);
        Assert::IsTrue(renameRegEx->PutFileTime(fileTime) == S_OK);
        unsigned long index = {};
        Assert::IsTrue(renameRegEx->Replace(sreTable[i].test, &result, index) == S_OK);
        Assert::IsTrue(wcscmp(result, sreTable[i].expected) == 0);
        CoTaskMemFree(result);
    }
}

TEST_METHOD (VerifyFileAttributesMonthAndDayNames)
{
    CComPtr<IPowerRenameRegEx> renameRegEx;
    Assert::IsTrue(CPowerRenameRegEx::s_CreateInstance(&renameRegEx) == S_OK);
    DWORD flags = MatchAllOccurrences | UseRegularExpressions;
    Assert::IsTrue(renameRegEx->PutFlags(flags) == S_OK);

    std::locale::global(std::locale(""));
    SYSTEMTIME fileTime = { 2020, 1, 3, 1, 15, 6, 42, 453 };
    wchar_t localeName[LOCALE_NAME_MAX_LENGTH];
    wchar_t dest[MAX_PATH] = L"bar";
    wchar_t formattedDate[MAX_PATH];
    if (GetUserDefaultLocaleName(localeName, LOCALE_NAME_MAX_LENGTH) == 0)
        StringCchCopy(localeName, LOCALE_NAME_MAX_LENGTH, L"en_US");

    GetDateFormatEx(localeName, NULL, &fileTime, L"MMM", formattedDate, MAX_PATH, NULL);
    formattedDate[0] = towupper(formattedDate[0]);
    StringCchPrintf(dest, MAX_PATH, TEXT("%s%s"), dest, formattedDate);

    GetDateFormatEx(localeName, NULL, &fileTime, L"MMMM", formattedDate, MAX_PATH, NULL);
    formattedDate[0] = towupper(formattedDate[0]);
    StringCchPrintf(dest, MAX_PATH, TEXT("%s-%s"), dest, formattedDate);

    GetDateFormatEx(localeName, NULL, &fileTime, L"ddd", formattedDate, MAX_PATH, NULL);
    formattedDate[0] = towupper(formattedDate[0]);
    StringCchPrintf(dest, MAX_PATH, TEXT("%s-%s"), dest, formattedDate);

    GetDateFormatEx(localeName, NULL, &fileTime, L"dddd", formattedDate, MAX_PATH, NULL);
    formattedDate[0] = towupper(formattedDate[0]);
    StringCchPrintf(dest, MAX_PATH, TEXT("%s-%s"), dest, formattedDate);

    SearchReplaceExpected sreTable[] = {
        //search, replace, test, result
        { L"foo", L"bar$MMM-$MMMM-$DDD-$DDDD", L"foo", dest },
    };

    for (int i = 0; i < ARRAYSIZE(sreTable); i++)
    {
        PWSTR result = nullptr;
        Assert::IsTrue(renameRegEx->PutSearchTerm(sreTable[i].search) == S_OK);
        Assert::IsTrue(renameRegEx->PutReplaceTerm(sreTable[i].replace) == S_OK);
        Assert::IsTrue(renameRegEx->PutFileTime(fileTime) == S_OK);
        unsigned long index = {};
        Assert::IsTrue(renameRegEx->Replace(sreTable[i].test, &result, index) == S_OK);
        Assert::IsTrue(wcscmp(result, sreTable[i].expected) == 0);
        CoTaskMemFree(result);
    }
}

TEST_METHOD(VerifyLookbehindFails)
{
    // Standard Library Regex Engine does not support lookbehind, thus test should fail.
    SearchReplaceExpected sreTable[] = {
        //search, replace, test, result
        { L"(?<=E12).*", L"Foo", L"AAAAAA", nullptr },
        { L"(?<!E12).*", L"Foo", L"AAAAAA", nullptr },
    };

    CComPtr<IPowerRenameRegEx> renameRegEx;
    Assert::IsTrue(CPowerRenameRegEx::s_CreateInstance(&renameRegEx) == S_OK);
    Assert::IsTrue(renameRegEx->PutFlags(UseRegularExpressions) == S_OK);

    for (int i = 0; i < ARRAYSIZE(sreTable); i++)
    {
        PWSTR result = nullptr;
        Assert::IsTrue(renameRegEx->PutSearchTerm(sreTable[i].search) == S_OK);
        Assert::IsTrue(renameRegEx->PutReplaceTerm(sreTable[i].replace) == S_OK);
        unsigned long index = {};
        Assert::IsTrue(renameRegEx->Replace(sreTable[i].test, &result, index) == E_FAIL);
        Assert::AreEqual(sreTable[i].expected, result);
        CoTaskMemFree(result);
    }
}

TEST_METHOD (Verify12and24HourTimeFormats)
{
    CComPtr<IPowerRenameRegEx> renameRegEx;
    Assert::IsTrue(CPowerRenameRegEx::s_CreateInstance(&renameRegEx) == S_OK);
    DWORD flags = MatchAllOccurrences | UseRegularExpressions;
    Assert::IsTrue(renameRegEx->PutFlags(flags) == S_OK);

    struct TimeTestCase {
        SYSTEMTIME time;        // Input time
        PCWSTR formatString;    // Format pattern
        PCWSTR expectedResult;  // Expected output
        PCWSTR description;     // Description of what we're testing
    };

    struct TimeTestCase testCases[] = {
        // Midnight (00:00 / 12:00 AM)
        { { 2025, 4, 4, 10, 0, 0, 0, 0 }, L"[$hh:$mm] [$H:$mm $tt]", L"[00:00] [12:00 am]", L"Midnight formatting" },

        // Noon (12:00 / 12:00 PM)
        { { 2025, 4, 4, 10, 12, 0, 0, 0 }, L"[$hh:$mm] [$H:$mm $tt]", L"[12:00] [12:00 pm]", L"Noon formatting" },

        // 1:05 AM
        { { 2025, 4, 4, 10, 1, 5, 0, 0 }, L"[$h:$m] [$H:$m $tt] [$hh:$mm] [$HH:$mm $TT]", 
          L"[1:5] [1:5 am] [01:05] [01:05 AM]", L"1 AM with various formats" },

        // 11 PM
        { { 2025, 4, 4, 10, 23, 45, 0, 0 }, L"[$h:$m] [$H:$m $tt] [$hh:$mm] [$HH:$mm $TT]", 
          L"[23:45] [11:45 pm] [23:45] [11:45 PM]", L"11 PM with various formats" },

        // Mixed formats in complex pattern
        { { 2025, 4, 4, 10, 14, 30, 0, 0 }, L"Date: $YYYY-$MM-$DD Time: $hh:$mm (24h) / $H:$mm $tt (12h)", 
          L"Date: 2025-04-10 Time: 14:30 (24h) / 2:30 pm (12h)", L"Complex combined format" },
    };

    for (int i = 0; i < ARRAYSIZE(testCases); i++)
    {
        PWSTR result = nullptr;
        Assert::IsTrue(renameRegEx->PutSearchTerm(L"test") == S_OK);
        Assert::IsTrue(renameRegEx->PutReplaceTerm(testCases[i].formatString) == S_OK);
        Assert::IsTrue(renameRegEx->PutFileTime(testCases[i].time) == S_OK);
        unsigned long index = {};
        Assert::IsTrue(renameRegEx->Replace(L"test", &result, index) == S_OK);
        Assert::IsTrue(wcscmp(result, testCases[i].expectedResult) == 0, 
                       (std::wstring(L"Failed test case: ") + testCases[i].description).c_str());
        CoTaskMemFree(result);
    }
}

};
}
</file>

<file path="resource.h">
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by PowerRenameUnitTests.rc

//////////////////////////////
// Non-localizable

#define FILE_DESCRIPTION "PowerToys PowerRename UnitTests"
#define INTERNAL_NAME "PowerRenameUnitTests"
#define ORIGINAL_FILENAME "PowerRenameUnitTests.dll"

// Non-localizable
//////////////////////////////
</file>

<file path="targetver.h">
#pragma once

// Including SDKDDKVer.h defines the highest available Windows platform.

// If you wish to build your application for a previous Windows platform, include WinSDKVer.h and
// set the _WIN32_WINNT macro to the platform you wish to support before including SDKDDKVer.h.

#include <SDKDDKVer.h>
</file>

<file path="TestFileHelper.cpp">
#include "pch.h"
#include "TestFileHelper.h"
#include <iostream>
#include <fstream>
#include <Objbase.h>

namespace fs = std::filesystem;

CTestFileHelper::CTestFileHelper()
{
    _CreateTempDirectory();
}
CTestFileHelper::~CTestFileHelper()
{
    _DeleteTempDirectory();
}

// Pass a relative path which will be appended to the temp directory path
bool CTestFileHelper::AddFile(_In_ const std::wstring path)
{
    fs::path newFilePath = _tempDirectory;
    newFilePath.append(path);
    std::ofstream ofs(newFilePath);
    ofs.close();
    return true;
}

// Pass a relative path which will be appended to the temp directory path
bool CTestFileHelper::AddFolder(_In_ const std::wstring path)
{
    fs::path newFolderPath = _tempDirectory;
    newFolderPath.append(path);
    return fs::create_directory(fs::path(newFolderPath));
}

fs::path CTestFileHelper::GetFullPath(_In_ const std::wstring path)
{
    fs::path fullPath = _tempDirectory;
    fullPath.append(path);
    return fullPath;
}

bool CTestFileHelper::PathExists(_In_ const std::wstring path)
{
    fs::path fullPath = _tempDirectory;
    fullPath.append(path);
    return fs::exists(fullPath);
}

bool CTestFileHelper::PathExistsCaseSensitive(_In_ const std::wstring path)
{
    fs::path tempDirPath = fs::path(_tempDirectory);
    for (const auto& entry : fs::directory_iterator(tempDirPath))
    {
        if (entry.path().filename().wstring() == path)
        {
            return true;
        }
    }
    return false;
}

bool CTestFileHelper::_CreateTempDirectory()
{
    // Initialize to the temp directory
    _tempDirectory = fs::temp_directory_path();

    // Create a unique folder name
    GUID guid = { 0 };
    CoCreateGuid(&guid);

    wchar_t uniqueName[MAX_PATH] = { 0 };
    StringFromGUID2(guid, uniqueName, ARRAYSIZE(uniqueName));

    _tempDirectory.append(uniqueName);

    return fs::create_directory(_tempDirectory);
}

void CTestFileHelper::_DeleteTempDirectory()
{
    fs::remove_all(_tempDirectory);
}
</file>

<file path="TestFileHelper.h">
#pragma once

#include <filesystem>
#include <string>
#include <windows.h>

class CTestFileHelper
{
public:
    CTestFileHelper();
    ~CTestFileHelper();

    bool AddFile(_In_ const std::wstring path);
    bool AddFolder(_In_ const std::wstring path);
    const std::filesystem::path GetTempDirectory() { return _tempDirectory; }
    bool PathExists(_In_ const std::wstring path);
    bool PathExistsCaseSensitive(_In_ const std::wstring path);
    std::filesystem::path GetFullPath(_In_ const std::wstring path);

private:
    bool _CreateTempDirectory();
    void _DeleteTempDirectory();

    std::filesystem::path _tempDirectory;
};
</file>

</files>
